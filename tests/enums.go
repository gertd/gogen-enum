//
// Code generated by gogen-enum DO NOT EDIT.
//
package tests

import (
	"bytes"
	"encoding/json"
	"strings"
)

// AddressKind -- enum type
type AddressKind int64

// AddressKind -- enum constants
const (
	AddressKindUnknown AddressKind = 0 + iota
	AddressKindHome
	AddressKindOffice
	AddressKindPostalBox
)

// addressKind -- enum string representation constants
const (
	addressKindUnknown   = "Unknown"
	addressKindHome      = "Home"
	addressKindOffice    = "Office"
	addressKindPostalBox = "PostalBox"
)

// AddressKindID -- map enum constant to string
var addressKindID = map[AddressKind]string{
	AddressKindUnknown:   addressKindUnknown,
	AddressKindHome:      addressKindHome,
	AddressKindOffice:    addressKindOffice,
	AddressKindPostalBox: addressKindPostalBox,
}

// AddressKindName -- map string to enum constant
var addressKindName = map[string]AddressKind{
	addressKindUnknown:   AddressKindUnknown,
	addressKindHome:      AddressKindHome,
	addressKindOffice:    AddressKindOffice,
	addressKindPostalBox: AddressKindPostalBox,
}

// NewAddressKind -- Create AddressKind instance from string representation
func NewAddressKind(k string) AddressKind {
	if kind, ok := addressKindName[k]; ok {
		return kind
	}
	return AddressKindUnknown
}

// String -- AddressKind
func (t AddressKind) String() string { return addressKindID[t] }

// MarshalJSON -- AddressKind
func (t AddressKind) MarshalJSON() ([]byte, error) {

	buffer := bytes.NewBufferString("\"")
	buffer.WriteString(addressKindID[t])
	buffer.WriteString("\"")
	return buffer.Bytes(), nil
}

// UnmarshalJSON -- AddressKind
func (t *AddressKind) UnmarshalJSON(b []byte) (err error) {

	var s string
	err = json.Unmarshal(b, &s)
	if err != nil {
		return err
	}
	*t = addressKindName[s]
	return nil
}

// Architecture -- enum type
type Architecture int

// Architecture -- enum constants
const (
	ArchitectureUnknown Architecture = 0 + iota
	ArchitectureX86
	ArchitectureX64
	ArchitectureARM
	ArchitecturePPC
)

// architecture -- enum string representation constants
const (
	architectureUnknown = "unknown"
	architectureX86     = "x86"
	architectureX64     = "x64"
	architectureARM     = "arm"
	architecturePPC     = "ppc"
)

// ArchitectureID -- map enum constant to string
var architectureID = map[Architecture]string{
	ArchitectureUnknown: architectureUnknown,
	ArchitectureX86:     architectureX86,
	ArchitectureX64:     architectureX64,
	ArchitectureARM:     architectureARM,
	ArchitecturePPC:     architecturePPC,
}

// ArchitectureName -- map string to enum constant
var architectureName = map[string]Architecture{
	architectureUnknown: ArchitectureUnknown,
	architectureX86:     ArchitectureX86,
	architectureX64:     ArchitectureX64,
	architectureARM:     ArchitectureARM,
	architecturePPC:     ArchitecturePPC,
}

// NewArchitecture -- Create Architecture instance from string representation
func NewArchitecture(k string) Architecture {
	if kind, ok := architectureName[k]; ok {
		return kind
	}
	return ArchitectureUnknown
}

// String -- Architecture
func (t Architecture) String() string { return architectureID[t] }

// PackageManager -- enum type
type PackageManager uint64

// PackageManager -- enum constants
const (
	PackageManagerUnknown PackageManager = 1 << iota
	PackageManagerDPKG
	PackageManagerAPK
	PackageManagerAPT
	PackageManagerYum
	PackageManagerZypper
	PackageManagerBrew
	PackageManagerChocolatey
	PackageManagerMSI
	PackageManagerAll = PackageManagerDPKG + PackageManagerAPK + PackageManagerAPT + PackageManagerYum + PackageManagerZypper + PackageManagerBrew + PackageManagerChocolatey + PackageManagerMSI
)

// packageManager -- enum string representation constants
const (
	packageManagerUnknown    = "Unknown"
	packageManagerDPKG       = "DPKG"
	packageManagerAPK        = "APK"
	packageManagerAPT        = "APT"
	packageManagerYum        = "Yum"
	packageManagerZypper     = "Zypper"
	packageManagerBrew       = "Brew"
	packageManagerChocolatey = "Chocolatey"
	packageManagerMSI        = "MSI"
	packageManagerAll        = "All"
)

// PackageManagerID -- map enum constant to string
var packageManagerID = map[PackageManager]string{
	PackageManagerUnknown:    packageManagerUnknown,
	PackageManagerDPKG:       packageManagerDPKG,
	PackageManagerAPK:        packageManagerAPK,
	PackageManagerAPT:        packageManagerAPT,
	PackageManagerYum:        packageManagerYum,
	PackageManagerZypper:     packageManagerZypper,
	PackageManagerBrew:       packageManagerBrew,
	PackageManagerChocolatey: packageManagerChocolatey,
	PackageManagerMSI:        packageManagerMSI,
	PackageManagerAll:        packageManagerAll,
}

// PackageManagerName -- map string to enum constant
var packageManagerName = map[string]PackageManager{
	strings.ToLower(packageManagerUnknown):    PackageManagerUnknown,
	strings.ToLower(packageManagerDPKG):       PackageManagerDPKG,
	strings.ToLower(packageManagerAPK):        PackageManagerAPK,
	strings.ToLower(packageManagerAPT):        PackageManagerAPT,
	strings.ToLower(packageManagerYum):        PackageManagerYum,
	strings.ToLower(packageManagerZypper):     PackageManagerZypper,
	strings.ToLower(packageManagerBrew):       PackageManagerBrew,
	strings.ToLower(packageManagerChocolatey): PackageManagerChocolatey,
	strings.ToLower(packageManagerMSI):        PackageManagerMSI,
	strings.ToLower(packageManagerAll):        PackageManagerAll,
}

// NewPackageManager -- Create PackageManager instance from string representation
func NewPackageManager(k string) PackageManager {
	if kind, ok := packageManagerName[strings.ToLower(k)]; ok {
		return kind
	}
	return PackageManagerUnknown
}

// String -- PackageManager
func (t PackageManager) String() string { return packageManagerID[t] }

// MarshalJSON -- PackageManager
func (t PackageManager) MarshalJSON() ([]byte, error) {

	buffer := bytes.NewBufferString("\"")
	buffer.WriteString(packageManagerID[t])
	buffer.WriteString("\"")
	return buffer.Bytes(), nil
}

// UnmarshalJSON -- PackageManager
func (t *PackageManager) UnmarshalJSON(b []byte) (err error) {

	var s string
	err = json.Unmarshal(b, &s)
	if err != nil {
		return err
	}
	*t = packageManagerName[s]
	return nil
}

// Set -- set flag
func (t *PackageManager) Set(flag PackageManager) {
	*t |= flag
}

// Clear -- clear flag
func (t *PackageManager) Clear(flag PackageManager) {
	*t &^= flag
}

// Toggle -- toggle flag state
func (t *PackageManager) Toggle(flag PackageManager) {
	*t ^= flag
}

// Has -- is flag set?
func (t PackageManager) Has(flag PackageManager) bool {
	return t&flag != 0
}

// Pluralize -- enum type
type Pluralize uint8

// Pluralize -- enum constants
const (
	PluralizeUnknown Pluralize = 1 << iota
	PluralizeIsPlural
	PluralizeIsSingular
	PluralizePlural
	PluralizeSingular
	PluralizeAll = PluralizeIsPlural + PluralizeIsSingular + PluralizePlural + PluralizeSingular
)

// pluralize -- enum string representation constants
const (
	pluralizeUnknown    = "Unknown"
	pluralizeIsPlural   = "IsPlural"
	pluralizeIsSingular = "IsSingular"
	pluralizePlural     = "Plural"
	pluralizeSingular   = "Singular"
	pluralizeAll        = "All"
)

// PluralizeID -- map enum constant to string
var pluralizeID = map[Pluralize]string{
	PluralizeUnknown:    pluralizeUnknown,
	PluralizeIsPlural:   pluralizeIsPlural,
	PluralizeIsSingular: pluralizeIsSingular,
	PluralizePlural:     pluralizePlural,
	PluralizeSingular:   pluralizeSingular,
	PluralizeAll:        pluralizeAll,
}

// PluralizeName -- map string to enum constant
var pluralizeName = map[string]Pluralize{
	pluralizeUnknown:    PluralizeUnknown,
	pluralizeIsPlural:   PluralizeIsPlural,
	pluralizeIsSingular: PluralizeIsSingular,
	pluralizePlural:     PluralizePlural,
	pluralizeSingular:   PluralizeSingular,
	pluralizeAll:        PluralizeAll,
}

// NewPluralize -- Create Pluralize instance from string representation
func NewPluralize(k string) Pluralize {
	if kind, ok := pluralizeName[k]; ok {
		return kind
	}
	return PluralizeUnknown
}

// String -- Pluralize
func (t Pluralize) String() string { return pluralizeID[t] }

// Set -- set flag
func (t *Pluralize) Set(flag Pluralize) {
	*t |= flag
}

// Clear -- clear flag
func (t *Pluralize) Clear(flag Pluralize) {
	*t &^= flag
}

// Toggle -- toggle flag state
func (t *Pluralize) Toggle(flag Pluralize) {
	*t ^= flag
}

// Has -- is flag set?
func (t Pluralize) Has(flag Pluralize) bool {
	return t&flag != 0
}
